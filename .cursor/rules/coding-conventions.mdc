---
description: WCPOS Platform coding conventions and architecture guidelines
globs:
alwaysApply: true
---

# Coding Conventions for WCPOS Platform

## ⚠️ IMPORTANT: AI Behavior Rules

### DO NOT MAKE ASSUMPTIONS
- **Never assume a hypothesis is correct without verification**
- When debugging, add log statements to confirm the hypothesis BEFORE making code changes
- Ask the user to run the code and provide log output
- Only implement a fix after the logs confirm the root cause

### Test Before Pushing
- **ALWAYS run tests locally before pushing to GitHub**
- Run `pnpm lint && pnpm build && pnpm test:unit` before every commit
- GitHub Actions will fail on type errors, lint errors, or test failures
- E2E tests run against real APIs - don't make strict assertions about external data

### Ask Before Widespread Changes
- **ALWAYS ask before making changes that affect multiple files** (more than 2-3 files)
- Propose the approach and get approval before implementing
- Consider architectural solutions (providers, services) instead of per-component changes

## Project Architecture

### Overview
This is a Next.js 16 monorepo that serves as:
- **Public API** for electron updates, license validation, etc.
- **Marketing website** at wcpos.com
- **User dashboard** for license management
- **Admin dashboard** for analytics and management

### Multi-Domain Setup
The project supports multiple domains via the proxy:
- `wcpos.com` - Main site (all routes)
- `updates.wcpos.com` - API only (restricted to `/api/*`)

Both domains point to the same Vercel deployment.

## Services Architecture (CRITICAL)

### Directory Structure
```
src/services/
├── api/                          # Entry point for server components
│   └── index.ts                  # Re-exports services
│
├── core/                         # Internal services (server-only)
│   ├── external/                 # Third-party API clients
│   │   └── github-client.ts      # Octokit wrapper
│   │
│   └── business/                 # Business logic layer
│       └── electron-service.ts   # Update logic
│
└── README.md                     # Architecture documentation
```

### Server-Only Protection
Critical server files MUST use `server-only` to prevent client-side imports:

```typescript
// ✅ REQUIRED at top of sensitive files
import 'server-only'

// This file will cause a build error if imported in a client component
```

Files that MUST have `server-only`:
- All files in `services/core/external/` (API keys, secrets)
- All files in `services/core/business/` (business logic)
- Any file accessing environment variables or databases

### Access Patterns

#### Public API Routes (`/api/*`)
Limited external endpoints for apps to check updates, validate licenses:

```typescript
// src/app/api/electron/[platform]/[version]/route.ts
import { electronService } from '@/services/core/business/electron-service'

export async function GET(request: Request, { params }: RouteParams) {
  const result = await electronService.getLatestUpdate(platform, version)
  return NextResponse.json(result)
}
```

#### Server Components (Internal)
Dashboard pages call services directly - NO public API needed:

```typescript
// src/app/dashboard/page.tsx (future)
import { licenseService } from '@/services/api'

export default async function DashboardPage() {
  // Direct function call on server - not an HTTP request
  const licenses = await licenseService.getUserLicenses()
  return <LicenseTable data={licenses} />
}
```

#### Server Actions (Mutations)
Form submissions use server actions - NO public API needed:

```typescript
// src/app/dashboard/actions.ts (future)
'use server'
import { licenseService } from '@/services/api'

export async function updateLicense(formData: FormData) {
  await licenseService.update(formData)
  revalidatePath('/dashboard')
}
```

### Security Model
```
External Apps → Public API Routes → Business Services → External APIs
                      ↓
Server Components → Business Services → Database
```

**Key principle**: Only expose what's necessary. Internal operations (logs, customer data, admin functions) should NEVER have public API endpoints.

## Next.js 16 Conventions

### Proxy (formerly Middleware)
Next.js 16 renamed `middleware.ts` to `proxy.ts` and `middleware()` to `proxy()`:

```typescript
// src/proxy.ts
export function proxy(request: NextRequest) {
  // Handle routing based on hostname, auth, etc.
  return NextResponse.next()
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico).*)'],
}
```

### API Route Params
In Next.js 16, route params are async:

```typescript
// ✅ Correct
interface RouteParams {
  params: Promise<{ platform: string; version: string }>
}

export async function GET(request: Request, { params }: RouteParams) {
  const { platform, version } = await params
  // ...
}
```

### Caching
Use `revalidate` for ISR-style caching on API routes:

```typescript
// Cache for 5 minutes
export const revalidate = 300
```

## Testing

### Testing Philosophy
| Test Type | Purpose | Data Source | Location |
|-----------|---------|-------------|----------|
| **Unit tests** | Verify business logic | Mocked data | `*.test.ts` alongside code |
| **E2E tests** | Verify API integration | Real external APIs | `e2e/` directory |

### Unit Tests (Vitest)
- Test business logic with mocked dependencies
- Place tests next to the code: `electron-service.test.ts`
- Mock external services (GitHub, databases)

```typescript
// ✅ Good - Mock external dependencies
vi.mock('../external/github-client', () => ({
  githubClient: {
    getLatestRelease: vi.fn(),
  },
}))
```

### E2E Tests (Playwright)
- Test against real running server
- Verify API response structure, NOT specific external data
- Real GitHub releases may change - don't assert on specific asset names

```typescript
// ✅ Good - Verify structure, not specific data
expect(data.data).toHaveProperty('version')
expect(Array.isArray(data.data.assets)).toBe(true)

// ❌ Bad - Assumes specific assets exist
expect(data.data.assets.some(a => a.name.endsWith('.AppImage'))).toBeTruthy()
```

### Running Tests
```bash
# Before every commit
pnpm lint           # ESLint
pnpm build          # TypeScript + Next.js build
pnpm test:unit      # Vitest unit tests

# Full test suite
pnpm test           # Unit + E2E

# E2E only (requires built app)
pnpm test:e2e       # All browsers
pnpm test:e2e --project=chromium  # Chromium only
```

## TypeScript Conventions

### Strict Types
- Avoid `any` - use proper types or `unknown`
- Export types from `src/types/` for reuse
- Use Zod for runtime validation (environment variables, API inputs)

```typescript
// ✅ Good - Proper typing
import type { GitHubAsset } from '@/types/github'

function filterAssets(assets: GitHubAsset[]): ElectronAsset[] {
  // ...
}

// ❌ Bad - Losing type safety
function filterAssets(assets: any[]): any[] {
  // ...
}
```

### Environment Variables
Always validate with Zod in `src/utils/env.ts`:

```typescript
import { z } from 'zod'

const envSchema = z.object({
  GITHUB_PAT: z.string().optional(),
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
})

export const env = envSchema.parse(process.env)
```

## GitHub Actions CI/CD

### Workflow Files
- `.github/workflows/ci.yml` - Lint, type check, unit tests, build
- `.github/workflows/e2e.yml` - Playwright E2E tests
- `.github/workflows/deploy.yml` - Vercel deployment

### Required Secrets
| Secret | Purpose |
|--------|---------|
| `GH_PAT` | GitHub Personal Access Token (for GitHub API) |
| `VERCEL_TOKEN` | Vercel deployment token |
| `VERCEL_ORG_ID` | Vercel organization/account ID |
| `VERCEL_PROJECT_ID` | Vercel project ID |

Note: Use `GH_PAT` not `GITHUB_PAT` - the `GITHUB_*` prefix is reserved by GitHub Actions.

## Adding New Features

### Adding a New Public API Endpoint
1. Create route in `src/app/api/[feature]/route.ts`
2. Create business service in `src/services/core/business/[feature]-service.ts` with `server-only`
3. Create external client in `src/services/core/external/` if needed (with `server-only`)
4. Add types to `src/types/`
5. Write unit tests for business logic
6. Write E2E tests for API endpoint
7. Run full test suite locally before pushing

### Adding a New Internal Feature (Dashboard)
1. Create page in `src/app/[feature]/page.tsx` (server component)
2. Create service in `src/services/core/business/`
3. Export from `src/services/api/index.ts` for server component access
4. Use server actions for mutations (no API route needed)
5. Write unit tests for business logic

## Logging

### Development
Use `console.log` sparingly during development. Remove before committing.

### Production (Future)
When logging service is implemented:
- Use structured logging with context
- Include error codes for user-facing errors
- Never log sensitive data (tokens, passwords, PII)

## Code Style

### Imports
Organize imports in this order:
1. Node built-ins
2. External packages
3. Internal aliases (`@/`)
4. Relative imports
5. Types (use `import type` when possible)

```typescript
import 'server-only'

import { NextResponse } from 'next/server'
import semver from 'semver'

import { githubClient } from '@/services/core/external/github-client'
import type { ElectronAsset } from '@/types/electron'
```

### File Naming
- `kebab-case` for files: `electron-service.ts`, `github-client.ts`
- `PascalCase` for React components: `DashboardPage.tsx`
- `[param]` for dynamic routes: `[platform]/[version]/route.ts`

### Comments
- Add JSDoc comments for exported functions
- Explain WHY, not WHAT (code should be self-documenting)
- Comment complex business logic or non-obvious decisions
